include ../../../src/pug/mixins/_mixins.pug

-var headDescription = "Detectar qué tipo de dispositivo se está usando al momento de navegar en un sitio es importante, esto es algo que CSS nos permite detectar para adaptar nuestros diseños. En este artículo explico en detalle estas herramientas.";

-var headTitle = "Media queries hover y pointer"

-var imageName = "media-query-hover-y-pointer"

-var dateTimeNumber = "2021-10-20"

-var dateTimeText = "Octubre 20 de 2021"

-var indexItems = [["Media query hover: detectando punteros", "media-query-hover"], ["Media query pointer: detectando la precisión de un puntero", "media-query-pointer"], ["Media queries any-hover y any-pointer: un nivel más de especificidad detectando punteros", "media-query-any-hover-y-any-pointer"]]

html(lang="es")
  head
    include ../../../src/pug/includes/_head.pug
  body
    include ../../../src/pug/includes/_header.pug
    main
      include ../../../src/pug/includes/_blog-entry__header.pug
      div(class="blog-grid | wrapper")
        include ../../../src/pug/includes/_blog-navbar.pug

        article(class="blog-entry | flow")
          include ../../../src/pug/includes/_summary.pug
          +sectionIntro
            p(data-no-top-margin="true") Nuestro paso por Internet está lleno de interacciones y muchas de estas suceden con solamente pasar un cursor por encima de un elemento, solamente para hacer una prueba lo hice con un tweet cualquiera y noté 11 cambios que ocurren bajo esta modalidad.
            p Seguramente tu como desarrollador #[span(lang="en") Front-End] estás familiarizado con esto, ya que es muy probable que lo has usado como trigger para activar transiciones y animaciones a elementos de un sitio. Es importante agregar este tipo de interacciones porque agregan feedback visual sobre los elementos con los cuales el usuario puede interactuar.
            p El problema viene cuando recordamos que la gente no solo ve el contenido a través de un PC o una laptop. También tenemos celulares, #[span(lang="en") tablets], televisores ¡y hasta consolas de videojuegos! Y muchos de estos dispositivos no tienen un puntero que pueda flotar sobre un elemento su forma principal de navegación.
            p Normalmente esto no supone un problema, ese nivel de interacción no supone mayor pérdida de información para el usuario; pero en otros casos si puede hacer la experiencia de navegar por tu sitio algo incómoda. 
            p Por suerte para nosotros, CSS trae una solución nativa y con amplio soporte la cual viene en forma de dos #[span(lang="en") media queries: hover] y #[span(lang="en") pointer]. En esta entrada de blog quiero hablar de que son, como funcionan y cómo podemos usarlas en conjunto para adaptar nuestros sitios a las necesidades de dispositivos específicos.
            include ../../../src/pug/includes/_content-table.pug
          +section(0)
            p La #[span(lang="en") media query hover] permite detectar si el dispositivo de entrada principal que el usuario utiliza puede flotar sobre elementos. Esta posee dos valores:
            ul.flow
              li #[code none] que revisa si el dispositivo no tiene un mecanismo de puntero primario, tal como los teléfonos celulares y algunas tablets.
              li #[code hover] que revisa si el dispositivo tiene algún mecanismo de entrada que puede flotar sobre algún elemento, tal como lo hace un mouse o un stylus.
            p Por dar un ejemplo, si queremos que nuestros botones cambien de color al poner el puntero sobre este, pero queremos que solamente pase en dispositivos que permitan flotar sobre un elemento, podríamos hacer esto:
            pre.language-css
              code 
                | @media (hover: hover) {
                |   button:hover {
                |     background: darkred;
                |   }
                | }
            +complement("Nota importante sobre dispositivos con touchpad")
              p Seguramente te preguntarás algo como “Oye, yo puedo activar las animaciones y transiciones de un sitio en mi celular si mantengo presionado un elemento” y si, eso es cierto. Sin embargo, esto no quiere decir que el dispositivo #[em tenga] un mecanismo de entrada que pueda flotar sobre los elementos, esto quiere decir que #[em emula] ese efecto a pesar de no tener dicho mecanismo.
              p En algunos dispositivos para emularlo hay que presionar el elemento en lugar de hacerle un tap, lo cual puede ser incómodo para algunos usuario. De ahí la importancia de tener estos dispositivos en cuenta.
            p Ya vimos un ejemplo básico de uso que realmente no interfiere mucho con la experiencia de usuario (es más, yo lo dejaría en un dispositivo sin puntero) Ahora veamos un ejemplo de uso de esta #[span(lang="en") media query] que cambia significativamente dicha experiencia. Este va a ser nuestro ejemplo:
            div.image-container 
              figure 
                img(src="/blog/src/images/media-query-hover-y-pointer/snippet-1.jpg", alt="Imagen de una card que tiene una imagen de fondo y el texto está sobre un background negro. El título tiene un subrayado y tiene un pequeño texto lorem y un botón que dice 'Leer más' al final" width=355 height=505 style="max-width: 355px")
            p Se ve bien ¿verdad?, bien, ¡Vamos a maquetarlo! Por practicidad, dejaré el código HTML y CSS a continuación, puedes copiarlo si gustas.
            details 
              summary HTML de la Card
              script(type="text/plain" class="language-markup")
                |<article class="card">
                |  <img
                |    class="card__background"
                |    src="https://images.unsplash.com/photo-1563770549-dd6dc8cdd629?ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&ixlib=rb-1.2.1&auto=format&fit=crop&w=375&q=80"
                |    alt="Vista de un canal del distrito de Abanotubani en Georgia"
                |    width="375"
                |    height="500"
                |  />
                |  <div class="card__content | flow">
                |    <div class="card__content--container | flow">
                |      <h2 class="card__title">Georgia</h2>
                |      <p class="card__description">
                |        Lorem ipsum dolor sit amet, consectetur adipisicing elit. Rerum in
                |        labore laudantium deserunt fugiat numquam.
                |      </p>
                |    </div>
                |    <button class="card__button">Leer más</button>
                |  </div>
                |</article>
            details 
              summary CSS de la card 
              pre.language-css
                code 
                  | @import url("https://fonts.googleapis.com/css2?family=Lato:wght@400;700&family=Montserrat:wght@700&display=swap");
                  | 
                  | :root {
                  |   /* Colors */
                  |   --brand-color: hsl(46, 100%, 50%);
                  |   --black: hsl(0, 0%, 0%);
                  |   --white: hsl(0, 0%, 100%);
                  |   /* Fonts */
                  |   --font-title: "Montserrat", sans-serif;
                  |   --font-text: "Lato", sans-serif;
                  | }
                  | 
                  | /* RESET */
                  | 
                  | /* Box sizing rules */
                  | *,
                  | *::before,
                  | *::after {
                  |   box-sizing: border-box;
                  | }
                  | 
                  | /* Remove default margin */
                  | body,
                  | h2,
                  | p {
                  |   margin: 0;
                  | }
                  | 
                  | /* GLOBAL STYLES */
                  | body {
                  |   display: grid;
                  |   place-items: center;
                  |   height: 100vh;
                  | }
                  | 
                  | h2 {
                  |   font-size: 2.25rem;
                  |   font-family: var(--font-title);
                  |   color: var(--white);
                  |   line-height: 1.1;
                  | }
                  | 
                  | p {
                  |   font-family: var(--font-text);
                  |   font-size: 1rem;
                  |   line-height: 1.5;
                  |   color: var(--white);
                  | }
                  |
                  | .flow > * + * {
                  |   margin-top: var(--flow-space, 1em);
                  | }
                  | 
                  | /* CARD COMPONENT */
                  | 
                  | .card {
                  |   display: grid;
                  |   place-items: center;
                  |   width: 80vw;
                  |   max-width: 21.875rem;
                  |   height: 31.25rem;
                  |   overflow: hidden;
                  |   border-radius: 0.625rem;
                  |   box-shadow: 0.25rem 0.25rem 0.5rem rgba(0, 0, 0, 0.25);
                  | }
                  | 
                  |  .card > * {
                  |   grid-column: 1 / 2;
                  |   grid-row: 1 / 2;
                  | }
                  | 
                  | .card__background {
                  |   object-fit: cover;
                  |   max-width: 100%;
                  |   max-height: 100%;
                  | }
                  | 
                  | .card__content {
                  |   --flow-space: 0.9375rem;
                  |   display: flex;
                  |   flex-direction: column;
                  |   justify-content: space-between;
                  |   align-self: flex-end;
                  |   height: 55%;
                  |   padding: 12% 1.25rem 1.875rem;
                  |   background: linear-gradient(
                  |     180deg,
                  |     hsla(0, 0%, 0%, 0) 0%,
                  |     hsla(0, 0%, 0%, 0.3) 10%,
                  |     hsl(0, 0%, 0%) 100%
                  |   );
                  | }
                  | 
                  | .card__content--container {
                  |   --flow-space: 1.25rem;
                  | }
                  | 
                  | .card__title {
                  |   position: relative;
                  |   width: fit-content;
                  |   width: -moz-fit-content; /* Prefijo necesario para Firefox  */
                  | }
                  | 
                  | .card__title::after {
                  |   content: "";
                  |   position: absolute;
                  |   height: 0.3125rem;
                  |   width: calc(100% + 1.25rem);
                  |   bottom: calc((1.25rem - 0.5rem) * -1);
                  |   left: -1.25rem;
                  |   background-color: var(--brand-color);
                  | }
                  | 
                  | .card__button {
                  |   padding: 0.75em 1.6em;
                  |   width: fit-content;
                  |   width: -moz-fit-content; /* Prefijo necesario para Firefox  */
                  |   font-variant: small-caps;
                  |   font-weight: bold;
                  |   border-radius: 0.45em;
                  |   border: none;
                  |   background-color: var(--brand-color);
                  |   font-family: var(--font-title);
                  |   font-size: 1.125rem;
                  |   color: var(--black);
                  | }
                  | 
                  | .card__button:focus {
                  |   box-shadow: inset 0 0 0 0.3em var(--brand-color), inset 0 0 0 0.45em black;
                  |   outline: none;
                  | }
            p Una vez maquetado, vamos a decidir cómo se animará al momento de pasar el puntero sobre este. En mi caso decidí estas animaciones.
            ul.flow 
              li La card aumentará levemente de tamaño.
              li El contenido va a iniciar más abajo, al poner el puntero sobre la card, este subirá a su posición original.
              li El subrayado del título (hecho con un pseudo elemento #[span(lang="en") after] va a aparecer de izquierda a derecha después de que el contenedor esté en posición.
              li Después de que este subrayado aparezca, el texto y el botón aparecerán.
            p Para esto vamos a agregarle unas declaraciones extra a los selectores #[code .card__content] y a #[code .card__title::after] para agregar un efecto de transición, además de agregar unas reglas para activar la animación al hacer #[span(lang="en") hover] al elemento.
            details 
              summary Animación de la card en CSS
              pre.language-css
                code /* REGLAS PARA DECLARAR EL ESTADO INICIAL DE LA CARD */
                  | 
                  | /* Adicionar a reglas anteriores  */
                  | 
                  | .card__content {
                  |   transform: translateY(62%);
                  |   transition: transform 500ms ease-out;
                  |   transition-delay: 500ms;
                  | }
                  | 
                  | .card__title::after {
                  |  opacity: 0;
                  |  transform: scaleX(0);
                  |  transition: opacity 1000ms ease-in, transform 500ms ease-out;
                  |  transition-delay: 500ms;
                  |  transform-origin: right;
                  | }
                  | 
                  | /* Reglas nueva */
                  | 
                  | .card__content--container > :not(.card__title),
                  | .card__button {
                  |   opacity: 0;
                  |   transition: transform 500ms ease-out, opacity 500ms ease-out;
                  | }
                  | 
                  | /* REGLAS PARA DECLARAR EL ESTADO AL HACER HOVER */
                  | 
                  | .card:hover,
                  | .card:focus-within {
                  |   transform: scale(1.05);
                  |   transition: transform 500ms ease-in;
                  | }
                  | 
                  | .card:hover .card__content,
                  | .card:focus-within .card__content {
                  |   transform: translateY(0);
                  |   transition: transform 500ms ease-in;
                  | }
                  | 
                  | .card:hover .card__content--container > :not(.card__title),
                  | .card:hover .card__button,
                  | .card:focus-within .card__content--container > :not(.card__title),
                  | .card:focus-within .card__button {
                  |   opacity: 1;
                  |   transition: opacity 500ms ease-in;
                  |   transition-delay: 1000ms;
                  | }
                  | 
                  | .card:hover .card__title::after,
                  | .card:focus-within .card__title::after {
                  |   opacity: 1;
                  |   transform: scaleX(1);
                  |   transform-origin: left;
                  |   transition: opacity 500ms ease-in, transform 500ms ease-in;
                  |   transition-delay: 500ms;
                  | }
            p Y así es como se ve nuestra #[span(lang="en") card] animada.
            video(controls width=522)
              source(src="/blog/src/videos/snippet-2.webm" type="video/webm")
              source(src="/blog/src/videos/snippet-2.mp4" type="video/mp4")
            +complement("Pseudo clase focus-within")
              p Seguramente viste en el código que cuando apliqué las reglas para activar la animación en un hover también usé estas mismas con una pseudo-clase llamada #[code focus-within]. Esta pseudo-clase agrega un estado a un elemento cuando #[em o algún elemento hijo] tenga el estado de #[span(lang="en") focus] (es decir, se haya seleccionado navegando con el teclado)
              p Debido a como funciona esta animación, si no agregamos esta regla, las personas que navegan con teclado no podrían ver la información de la #[span(lang="en") card], creando un problema de accesibilidad, por lo para este caso decidí tenerlo en mente al hacer que la animación se active también si se navega por teclado.
            p La animación en serio le da vida, pero tenemos un problema: los usuarios de teléfonos, #[span(lang="en") tablets] y otros dispositivos sin un puntero no van a poder ver la información al menos que presionen la #[span(lang="en") card] con su dedo por un momento, lo cual no es muy intuitivo.
            p Podemos arreglar esto gracias a la #[span(lang="en") media query hover], lo que debemos hacer es agregar todas las animaciones que queramos que solo ocurran en dispositivos con un puntero dentro de esta.
            p En este caso sería todas las animaciones que involucran la presentación del contenido: que la tarjeta se desplace, la animación de subrayado y que el texto aparezca. La animación de la #[span(lang="en") card] aumentando de tamaño podría dejarse para dispositivos sin puntero si gustas dejar alguna animación para darle #[span(lang="en") feedback] visual al usuario. Eso ya queda a tu decisión, en mi caso decidí que esta animación también se verá solamente para dispositivos que tengan puntero.
            p Las reglas de CSS que activan la animación irían dentro de la #[span(lang="en") media query]. Así es como se vería (Recuerda eliminar lo que agregamos en el paso anterior en #[code .card__content] y  #[code .card__title::after] ya que esto irá dentro de la #[span(lang="en") media query hover])
            details 
              summary Animación de la card en CSS (media query: hover)
              pre.language-css
                code @media (hover: hover) {
                  | /* Reglas de elementos anteriores que movemos a la media query */
                  | 
                  |   .card__content {
                  |     transform: translateY(62%);
                  |     transition: transform 500ms ease-out;
                  |     transition-delay: 500ms;
                  |   }
                  |   
                  |  .card__title::after {
                  |     opacity: 0;
                  |     transform: scaleX(0);
                  |     transition: opacity 1000ms ease-in, transform 500ms ease-out;
                  |     transition-delay: 500ms;
                  |     transform-origin: right;
                  |   }
                  |   
                  |   /* Reglas relacionadas a la animación del elemento */
                  |   
                  |   .card__content--container > :not(.card__title),
                  |   .card__button {
                  |     opacity: 0;
                  |     transition: transform 500ms ease-out, opacity 500ms ease-out;
                  |   }
                  | 
                  |   .card:hover,
                  |   .card:focus-within {
                  |     transform: scale(1.05);
                  |     transition: transform 500ms ease-in;
                  |   }
                  | 
                  |   .card:hover .card__content,
                  |   .card:focus-within .card__content {
                  |     transform: translateY(0);
                  |     transition: transform 500ms ease-in;
                  |   }
                  |   
                  |   .card:focus-within .card__content {
                  |     transition-duration: 0ms;
                  |   }
                  |   
                  |   .card:hover .card__content--container > :not(.card__title),
                  |   .card:hover .card__button,
                  |   .card:focus-within .card__content--container > :not(.card__title),
                  |   .card:focus-within .card__button {
                  |     opacity: 1;
                  |     transition: opacity 500ms ease-in;
                  |     transition-delay: 1000ms;
                  |   }
                  | 
                  |   .card:hover .card__title::after,
                  |   .card:focus-within .card__title::after {
                  |     opacity: 1;
                  |     transform: scaleX(1);
                  |     transform-origin: left;
                  |     transition: opacity 500ms ease-in, transform 500ms ease-in;
                  |     transition-delay: 500ms;
                  |   }
                  | }
            p Y así es como se vería en desktop y en mobile: 
            div.image-container
              figure.flow
                img(src="/blog/src/images/media-query-hover-y-pointer/snippet-2-desktop.png" alt="Diseño de la card completado en un computador de escritorio, donde se ve el contenido oculto esperando que se active la animación." width=355 height=505)
                div
                  figcaption Estado inicial de la card en desktop, donde se ve que el contenido está oculto y se mostrará cuando el cursor se pose sobre esta.
              figure.flow
                img(src="/blog/src/images/media-query-hover-y-pointer/snippet-2-mobile.png" alt="Diseño de la card en mobile, donde se ve que está mostrando todo el contenido." width=355 height=505)
                figcaption Diseño de la card en un dispositivo sin puntero donde se ve el contenido de la card completo, ya que este no tiene animación.
            p Y esto hubiera sido todo el artículo de no ser por algo más que pasó. Verán, este diseño fue una práctica que hice hace unos meses siguiendo #[a( class="link" href="https://youtu.be/5DEq5cWNYt8" target="_blank" rel="noopener noreferrer") este video de Kevin Powell] (canal que en serio recomiendo si quieren aprender de CSS) donde incluye el tema de la #[span(lang="en") media query hover]. Lo hice, se lo mostré a un amigo... Y la animación en su celular seguía mostrándose. ¿La razón? Él tiene un Samsung #[span(lang="en") Galaxy Note 9].
            p Este dispositivo cuenta con un #[span(lang="en") stylus], el cual es un dispositivo de entrada que funciona como puntero, por lo tanto, #[strong la #[span(lang="en") media query hover] lo detectará como un dispositivo con puntero] por lo que en un #[span(lang="en") Galaxy Note] se verá la animación.
            p ¿Queremos que eso suceda? Yo por lo personal no. No creo que sea muy intuitivo que un usuario con un #[span(lang="en") stylus] tenga que presionar la #[span(lang="en") card] para que muestre el contenido. ¿Podemos evaluar este tipo de casos? La respuesta es sí, y de nuevo, CSS entra al rescate con una solución bastante sencilla al respecto. Esta consiste en el uso de otra #[span(lang="en") media query] de la cual hablaré en este artículo.
          +section(1)
            p A veces no solo basta con detectar si el dispositivo tiene un puntero, también hay que determina la #[em precisión] de este, y para esto usamos la #[span(lang="en") #[em media query pointer]]. Esta tiene tres valores: 
            ul.flow
              li #[code none] en la que el dispositivo en cuestión no posee un puntero como mecanismo principal de navegación.
              li #[code coarse] donde revisa si el dispositivo tiene como mecanismo principal de navegación un puntero poco preciso (como #[span(lang="en") touchscreens], algunos controles de televisor o incluso #[span(lang="en") wiimotes])
              li #[code fine] la cual busca si el dispositivo tiene como mecanismo de navegación un puntero que sea preciso (como #[span(lang="en") stylus] o un #[span(lang="en") mouse])
            p Antes de entrar en detalle de como usaríamos esta #[span(lang="en") media query] para nuestra #[span(lang="en") card], quiero mencionar su potencial para solucionar algunos temas de accesibilidad: saber si un dispositivo tiene un puntero poco preciso nos ayuda a crear elementos que sean más fáciles de interactuar en estos casos.
            p Solo por comentar un caso personal, me ocurre a menudo que cuando navego en mi celular, a veces presiono por error un enlace o botón de una lista que no quería porque no hay suficiente espacio entre las opciones, o porque son muy pequeñas (es eso o tengo dedos gordos) lo que puede generar cierto malestar para el usuario, y es ahí donde entra la #[span(lang="en") media query pointer] para ayudarnos a resolver estos detalles. Veámoslo con un ejemplo rápido.
            p Creemos un formulario en el que seleccionaremos algunas opciones, pero asegurémonos que en elementos con un puntero poco precioso tengan el suficiente espacio para evitar seleccionar alguna opción que no quieras. Para eso tenemos este código HTML y CSS.
            details 
              summary HTML del formulario
              script(type="text/plain" class="language-markup")
                | <form action="post">
                |   <fieldset>
                |     <legend>¿Qué lenguajes de programación quieres aprender?</legend>
                |     <div class="language-grid">
                |       <label for="c"> <input type="checkbox" id="c" /> C </label>
                |       <label for="c+"> <input type="checkbox" id="c+" /> C+ </label>
                |       <label for="c++"> <input type="checkbox" id="c++" /> C++ </label>
                |       <label for="c-sharp"> <input type="checkbox" id="c-sharp" /> C# </label>
                |       <label for="kotlin"> <input type="checkbox" id="kotlin" /> Kotlin </label>
                |       <label for="java"> <input type="checkbox" id="java" /> Java </label>
                |       <label for="javascript"> <input type="checkbox" id="javascript" /> JavaScript </label>
                |       <label for="go"> <input type="checkbox" id="go" /> Go </label>
                |       <label for="objective-c"> <input type="checkbox" id="objective-c" /> Objective-C </label>
                |       <label for="php"> <input type="checkbox" id="php" /> PHP </label>
                |       <label for="python"> <input type="checkbox" id="python" /> Python </label>
                |       <label for="ruby"> <input type="checkbox" id="ruby" /> Ruby </label>
                |       <label for="rust"> <input type="checkbox" id="rust" /> Rust </label>
                |       <label for="scala"> <input type="checkbox" id="scala" /> Scala </label>
                |       <label for="swift"> <input type="checkbox" id="swift" /> Swift </label>
                |       <label for="other"> <input type="checkbox" id="other" /> Otro </label>
                |     </div>
                |     <button type="button">Enviar</button>
                |   </fieldset>
                | </form>
            details
              summary CSS del formulario
              pre.language-css
                code
                  | @import url("https://fonts.googleapis.com/css2?family=Fira+Sans:wght@400;700&display=swap");
                  | 
                  | body {
                  |   font-family: "Fira Sans", sans-serif;
                  | }
                  | 
                  | fieldset {
                  |   padding: 0.6em 1em 2em;
                  |   border-radius: 1em;
                  |   border-color: #722f37;
                  |   box-shadow: 0.25rem 0.25rem 0.2rem rgba(0, 0, 0, 0.25);
                  | }
                  | 
                  | legend {
                  |   font-size: 1.3rem;
                  |   text-align: center;
                  |   font-weight: bold;
                  | }
                  | 
                  | form {
                  |   max-width: 53.125rem;
                  |   margin: 0 auto;
                  | }
                  | 
                  | input[type="checkbox"] {
                  |   margin-inline-end: 0.5em;
                  |   accent-color: #722f37;
                  | }
                  | 
                  | input[type="checkbox"]:focus {
                  |   outline: 2px solid #722f37;
                  |   outline-offset: 0.2em;
                  | }
                  | 
                  | label {
                  |   display: flex;
                  |   align-items: center;
                  | }
                  | 
                  | .language-grid {
                  |   display: grid;
                  |   grid-template-columns: repeat(auto-fit, minmax(8rem, 1fr));
                  |   gap: 0.3em;
                  |   margin-bottom: 1.2em;
                  |   align-items: center;
                  | }
                  | 
                  | button[type="button"] {
                  |   display: block;
                  |   margin: 0 auto;
                  |   padding: 0.3em 1em;
                  |   color: white;
                  |   font-weight: bold;
                  |   background-color: #722f37;
                  |   font-size: 1.25rem;
                  |   border: none;
                  |   border-radius: 0.5em;
                  | }
                  | 
                  | button[type="button"]:focus {
                  |   outline: 2px solid #722f37;
                  |   outline-offset: 0.4em;
                  | }
                  | 
                  | @media screen and (pointer: coarse) {
                  |   .language-grid {
                  |     row-gap: 0.5em;
                  |   }
                  | 
                  |   label {
                  |     font-size: 1.05em;
                  |   }
                  | 
                  |   input[type="checkbox"] {
                  |     width: 1.625rem;
                  |     height: 1.625rem;
                  |   }
                  | 
                  |   button[type="button"] {
                  |     min-height: 3rem;
                  |   }
                  | }
            p El CSS en su mayor parte es solo para salirnos del formato estándar, pero enfoquémonos en el código dentro de la #[span(lang="en") media query] para ver los cambios que hay en pantallas sin un puntero preciso:
            ul.flow 
              li El espacio entre fila y fila es un poco más grande (de 0.3em a 0.5em) evitando así la probabilidad de que por error el usuario seleccione una opción incorrecta.
              li Los elementos input pasan de 16px a 26px (todo expresado en rem) para que sea más fácil hacerle tap. El texto del elemento #[code label] incrementa ligeramente de tamaño para que no sea disonante la diferencia de tamaño entre el checkbox y el texto.
              li El botón de Enviar cambia su alto mínimo a 48px (de nuevo, expresado en rem) Esto se debe a que 48px equivalen más o menos a 9mm, que es el tamaño del área de un tap.
            p Son cambios pequeños, pero esos detalles mejoran mucho la experiencia en dispositivos con punteros poco precisos, lo cual vale la pena considerar.
            +complement("Propiedad accent-color")
              p En el CSS probablemente viste que a los <code>input[type=”checkbox”]</code> le puse una propiedad llamada #[code accent-color]. Esta propiedad es muy nueva y permite darle color a los elementos que tienen énfasis como los input tipo checkbox, radio y range.
              p Esto permite añadir estilos a estos #[code input] muy fácilmente y en el caso de los input tipo #[span(lang="en") checkbox], viene con la accesibilidad en mente, ya que mide automáticamente el contraste del elemento check dentro de este para que sea visible siempre con el #[code accent-color] escogido.
              p A la fecha, está bien soportado en los navegadores actuales (solo Safari no lo ha implementado) Si quieres ver más de este tema, te dejo #[a.link(href="https://www.youtube.com/watch?v=MRahw3qnRBQ" target="_blank" rel="noopener noreferrer") este video donde Kevin Powell habla sobre el tema]
            p Ahora que vimos un ejemplo de cómo funciona la #[span(lang="en") media query pointer] te debes estar preguntando como hacemos para resolver el problema que mencioné de nuestra #[span(lang="en") card], y la respuesta a esto está en combinar #[strong ambas #[span(lang="en") media queries]] de modo tal que pueda detectar ciertos dispositivos.
            p Examinemos nuestro caso: queremos que nuestra animación se vea en un computador. Estos son dispositivos que tienen un puntero, por lo que usaríamos #[code @media (hover: hover)] y el puntero de estos es uno preciso, por lo que usaríamos #[code @media (pointer: fine)]. Combinando estas propiedades, podemos reemplazar la media query que usamos anteriormente por
            p #[pre.language-css #[code @media (hover: hover) and (pointer: fine)]]
            p Combinando estas dos herramientas podemos detectar dispositivos específicos, lo que nos ayudará a adaptar nuestros sitios a las necesidades de estos. En la tabla que verás a continuación vas a encontrar qué dispositivos puedes detectar combinando ambas #[span(lang="en") media queries].
            table
              caption Equipos que se pueden detectar combinando las media query hover y pointer
              thead 
                tr 
                  th(scope="col") Valor media query hover
                  th(scope="col") Valor media query pointer
                  th(scope="col") Dispositivo
              tbody 
                tr 
                  th(scope="row" rowspan="2") #[code none]
                  th(scope="row") #[code coarse]
                  td Pantallas con #[span(lang="en") stylus]
                tr 
                  th(scope="row") #[code fine]
                  td #[span(lang="en") Smartphones, touchscreens]
                tr 
                  th(scope="row" rowspan="2") #[code hover]
                  th(scope="row") #[code coarse]
                  td #[span(lang="en") Smart TV], consolas de videojuegos 
                tr 
                  th(scope="row") #[code fine]
                  td 	Computadores, #[span(lang="en") laptops]
            p Así que ya sabes, si necesitas aplicar algunas propiedades específicas de CSS a estos dispositivos ¡las #[span(lang="en") media query hover] y #[span(lang="en") pointer] son tu mejor alternativa!
            p Podría terminar el blog aquí, pero hay un detalle: como dije en un principio estas dos #[span(lang="en") media queries] solo detectan si el puntero #[em principal] del dispositivo coincide con la condición que queremos evaluar. Esto cubre muchos casos, pero tal vez quieras tener otros en consideración dispositivos más específicos. La buena noticia es que podemos evaluar estos casos específicos con CSS. Veamos un poco más de esto en la siguiente sección.
          +section(2)
            p Veamos un poco los siguientes casos:
            div.image-container
              figure.flow
                img(src="https://i1.wp.com/css-tricks.com/wp-content/uploads/2020/09/RYMHpR9b-2.jpeg?resize=1000%2C750&ssl=1" alt="Teléfono Android con mouse y teclado conectados vía Bluetooth" width=1000 height=750)
                div
                  figcaption Un teléfono Android con un #[span(lang="en") mouse] y un teclado conectados via Bluetooth. Se puede ver como se está haciendo #[span(lang="en") click] con el botón derecho. Imagen tomada de #[cite CSS Tricks].
              figure.flow
                img(src="/blog/src/images/media-query-hover-y-pointer/control-inalambrico.jpg" alt="Mini control inalámbrico con touchpad que funciona en dispositivos como consolas y televisores" width=960 height=720)
                figcaption Un mini-control inalámbrico que permite controlar dispositivos como consolas y televisores. Aparte de tener teclado, tiene un #[span(lang="en") touchpad] que permite usar un mouse en estos dispositivos.
            p En la primera podemos ver que, a pesar de ser un celular, este tiene conectado a través de Bluetooth un teclado y un #[span(lang="en") mouse]. Con lo que hemos aprendido hasta ahora no podríamos detectar el mouse porque la #[span(lang="en") media query pointer] sólo detecta la precisión del puntero principal del dispositivo (en este caso, el #[span(lang="en") touchpad]) y el #[span(lang="en") mouse] no será detectado.
            p El segundo es un control inalámbrico que puede conectarse a varios dispositivos: consolas, #[span(lang="en") Smart] TVs, incluso computadores o La #[span(lang="en") laptops]. Aparte de agregar un teclado, también se puede usar como un La #[span(lang="en") touchpad], lo que añade un puntero preciso. Esto es particularmente útil en un televisor, donde navegar a través de un control puede ser muy molesto.
            p ¿Qué tienen estos casos en común? Estos nos añaden nuevas opciones de navegar por dispositivos que #[strong no] son detectadas por las media queries vistas anteriormente al no ser métodos #[em primarios] de navegación. Por suerte para nosotros, CSS tiene esto cubierto con otras dos medias queries: #[code any-hover] y #[code any-pointer].
            p La #[span(lang="en") media query] #[code any-hover] nos permite detectar si cualquiera de las opciones de entrada del dispositivo puede flotar sobre un elemento, ya no solo el método principal del dispositivo. Al igual que la #[span(lang="en") media query hover], esta tiene dos valores: #[code none] y #[code hover]. La diferencia está en los resultados que obtienes con esta.
            p Sólo con este cambio, la #[span(lang="en") media query] #[code any-hover] podría detectar un dispositivo que normalmente no tiene un puntero (como un iPad) que tiene conectado un #[span(lang="en") mouse]. Esto solo ya abre más posibilidades al momento de adaptar nuestros diseños a otros dispositivos.
            p Por otro lado, la #[span(lang="en") media query] #[code any-pointer], como podrás suponer, nos permite evaluar el nivel de precisión de  cualquiera de las opciones de entrada de un dispositivo, y al igual que la #[span(lang="en") media query pointer], tiene tres opciones: #[code none] (el dispositivo definitivamente no tiene un puntero) #[code coarse] (el dispositivo tiene al menos un puntero poco preciso) y #[code fine] (el dispositivo tiene al menos una opción de puntero precisa).
            p Si bien la sintaxis entre estas dos y las que vimos anteriormente es básicamente idéntida, tiene distintos resultados. Para empezar, ahora podremos revisar casos como los que vimos al inicio de esta sección de un dispositivo que por si solo no tiene un puntero (o es un puntero poco preciso) pero se conectó un dispositivo que añade esta posibilidad. Puedes ver que tipo de escenarios puedes detectar con estas #[span(lang="en") media queries] en el siguiente listado.
            dl.flow
              div
                div 
                  dt #[code any-pointer: coarse]
                div.flow
                  dd #[span(lang="en") Touchscreen]
                  dd #[span(lang="en") Touchscreen] y #[span(lang="en") mouse]
                  dd Computador con #[span(lang="en") touchscreen]
              div
                div 
                  dt #[code any-pointer: fine]
                div.flow
                  dd #[span(lang="en") Touchscreen] y #[span(lang="en") mouse]
                  dd Computador
                  dd Computador con #[span(lang="en") touchscreen]
              div
                div 
                  dt #[code any-hover: none]
                div.flow
                  dd #[span(lang="en") Touchscreen]
              div
                div 
                  dt #[code any-pointer: hover]
                div.flow
                  dd #[span(lang="en") Touchscreen] y #[span(lang="en") mouse]
                  dd Computador
                  dd Computador con #[span(lang="en") touchscreen]
            p Aquí no termina esto. También podemos combinar las cuatro #[span(lang="en") media queries] que vimos para adaptar nuestros sitios a algunos escenarios extra. Veamos un par de ejemplos:
            ul.flow 
              li #[code @media (pointer: fine) and (any-pointer: coarse)] Nos permite identificar si el dispositivo tiene un puntero como método de entrada principal y a su vez tiene una #[span(lang="en") touchscreen]. Esto puede ser útil en caso si queremos que incluso en estos escenarios los elementos de nuestro sitio que requieran interacción (como botones o #[span(lang="en") inputs]) tengan algún cambio para hacer más fácil su interacción en caso de que el usuario quiera usar la #[span(lang="en") touchscreen].
              li #[code @media (pointer: coarse) and (any-pointer: fine)] cubriría dispositivos que estén pensados para manejarse con un puntero poco preciso pero que tengan algún puntero preciso como navegación secundaria (un #[span(lang="en") stylus] o tal vez un #[span(lang="en") mouse]) Con estas especificaciones, podríamos hacer nuestro diseño enfocado a dispositivos touch y que funcionen igual de bien si se usa el puntero de este dispositivo.
            p Como puedes ver, este tema de detección de puntero tiene muchos matices en medio y con CSS eres capaz de adaptar tu sitio a diversos escenarios, pero tal vez con eso no sea suficiente. Esto también varía un poco de navegador en navegador y a veces se hace necesario el uso de JavaScript para reforzar la experiencia.
            p Este es un tema que puede llegar a ser complejo, y creo que ya abarqué lo suficiente. Si quieren saber más del tema, te dejo #[a.link(href="https://css-tricks.com/interaction-media-features-and-their-potential-for-incorrect-assumptions/" target="_blank" rel="noopener noreferrer") este artículo de Patrick H. Lauke] en CSS Tricks sobre el tema. Menciona temas sobre algunas asumpciones incorrectas que podemos hacer, los beneficios de darle al usuario opciones explícitas para cambiar esto y algunas buenas prácticas a tener en cuenta.
          +sectionOutro()
            p Navegar por la web es algo que se puede hacer a través de muchos dispositivos y puede que tener en cuenta varios matices en nuestros diseños para poder adaptarlos a las necesidades específicas de cada uno. 
            p Gracias a lo mucho que ha avanzado CSS, podemos tener la gran mayoría de estos casos en cuenta gracias a las #[span(lang="en") media query hover, pointer, any-hover] y #[span(lang="en") any-pointer]. También recuerda ver el artículo que dejé en la sección anterior por si quieres saber algo más del tema.

    include ../../../src/pug/includes/_footer.pug

    script(src="/src/js/utils/blogContentAnimation.js")
    script(src="/blog/src/javascript/prism.js")